---
title: "Mst package - Rapport"
author: "Rabab Khatib, Gabriele Pedroni, Nawal Bendjelloul"
date: "2024-04-11"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Minimum Spanning Tree Package

## Introduction

### Contexte - Principe

Le Minimum Spanning Tree (MST) est un arbre couvrant de poids minimal d'un graphe connexe et pondéré. Il s'agit d'un sous-graphe acyclique qui relie tous les sommets du graphe original en minimisant la somme des poids des arêtes.

Il existe plusieurs algorithmes classiques pour trouver le MST d'un graphe, tels que l'algorithme de Kruskal et l'algorithme de Prim que nous avons choisi d'implementer ici. Ces algorithmes reposent sur des stratégies différentes pour sélectionner les arêtes à inclure dans l'arbre couvrant, mais ils garantissent tous les deux de trouver une solution optimale.

Ce package se veut notamment de résoudre efficacement des problèmes de MST sur des graphes de grande taille, spécifiques à la modélisation dans le domaine de la santé.

### Applications

Le MST a de nombreuses applications en santé, notamment dans l'analyse de données génomiques et protéomiques [étude à grande échelle des protéines]. Parmi les exemples d'applications en santé nous pouvons citer :

-   La **reconstruction de génomes** d'organismes à partir de fragments d'ADN. En utilisant un graphe dont les sommets représentent les fragments d'ADN et les arêtes représentent les chevauchements entre les fragments, le MST permet de trouver le chemin le plus court qui relie tous les fragments, ce qui correspond au génome complet de l'organisme.

-   L'**analyse de réseaux métaboliques**, en représentant par les sommets les métabolites et par les arêtes les réactions chimiques entre eux. Le MST peut être utilisé pour identifier les voies métaboliques les plus importantes dans le réseau, en sélectionnant les arêtes qui ont le poids le plus faible et donc les réactions les plus efficaces.

-   L'**analyse de données de séquençage**, où le MST est utilisé pour comparer des séquences d'ADN ou d'ARN et identifier les mutations qui les distinguent. En construisant un graphe dont les sommets représentent les séquences et les arêtes représentent les différences entre les séquences, le MST permet de trouver le chemin le plus court qui relie toutes les séquences, ce qui correspond à l'ensemble des mutations qui les séparent.

## Algorithme de Prim

### Présentation

L'**algorithme de Prim**, popularisé par Prim en 1957, est un algorithme de graphes trouvant un **arbre couvrant minimal** pour un graphe connexe pondéré non dirigé.\
Son objectif est de connecter tous les sommets du graphe avec les arêtes de poids minimal possible, sans former de cycle, pour que le poids total de l'arbre couvrant minimal soit le plus bas possible.

### Le principe

L'algorithme de Prim commence par un **sommet arbitraire** et s'étend étape par étape jusqu'à couvrir tous les sommets du graphe. À chaque étape, il ajoute l'**arête de poids minimal** **disponible** qui connecte un sommet de l'arbre en construction à un sommet en dehors de l'arbre.

### Etape de l'algorithme

1.  **Initialisation** : Sélectionner un sommet de départ arbitraire du graphe.
2.  **Sélection des Arêtes** : À partir du sommet sélectionné, choisir l'arête de poids minimal qui connecte un sommet déjà dans l'arbre à un sommet qui n'est pas encore dans l'arbre.
3.  **Ajout à l'Arbre** : Ajouter le sommet sélectionné à l'arbre, ainsi que l'arête choisie.
4.  **Répétition** : Répéter les étapes 2 et 3 jusqu'à ce que tous les sommets soient inclus dans l'arbre.

### Exemple d'application de l'algorithme

![](images/clipboard-3144098367.png)

### Propriétés

-   **Greedy Algorithm** : à chaque étape, il fait le choix optimal local dans l'espoir que ce choix conduira à une solution optimale globale.

-   **Indépendant du Sommet de Départ** : peu importe le sommet de départ, l'algorithme trouve toujours le même arbre couvrant minimal. Cela montre la fiabilité de l'algorithme pour fournir un résultat consistant et optimal indépendamment de sommet initial choisi.

## Algorithme de Kruskal

## Implémentation des algorithmes en R

## Implémentation des algorithmes en Rcpp

## Comparaison

Fonction qui calcule le temps

```{r}
library(mstPackage)

one.simu <- function(func = "prim_mst", ajd_matrix = NULL) {
  start_time <- NA
  end_time <- NA

  if (func == "prim_mst") {
    start_time <- Sys.time()
    mst <- prim_mst(adj_matrix)
    end_time <- Sys.time()

  } else if (func == "kruskal_mst") {
    start_time <- Sys.time()
    mst <- kruskal_mst(adj_matrix)
    end_time <- Sys.time()
  }
  else if (func == "kruskal_mst_rcpp") {
    start_time <- Sys.time()
    mst <- kruskal_mst_rcpp(adj_matrix)
    end_time <- Sys.time()
  }
  else if (func == "prim_mst_rcpp") {
    start_time <- Sys.time()
    mst <- prim_mst_rcpp(adj_matrix)
    end_time <- Sys.time()
  }

  return(unclass(end_time - start_time)[1])
}
```

#### Analyse meilleurs / pires des cas 

simulation simple, sur n petit 

```{r}
n <- 5 
adj_matrix <- generate_random_adjacency_matrix(n)
one.simu(func = "prim_mst", adj_matrix)
one.simu(func = "kruskal_mst", adj_matrix)
one.simu(func = "prim_mst_rcpp",adj_matrix)
one.simu(func = "kruskal_mst_rcpp",adj_matrix)
```

simulation simple, sur n grand : 

```{r}
n <- 100 
adj_matrix <- generate_random_adjacency_matrix(n)
one.simu(func = "prim_mst", adj_matrix)
one.simu(func = "kruskal_mst", adj_matrix)
one.simu(func = "prim_mst_rcpp",adj_matrix)
one.simu(func = "kruskal_mst_rcpp",adj_matrix)
```

meilleur : sur ACM

```{r}
# Génération de la matrice d'adjacence pour un ACM "optimal" 
# (où le graphe est déjà un ACM minimal)
meilleur_acm <- matrix(
  c(Inf, 1,   Inf, Inf,
    1,   Inf, 1,   Inf,
    Inf, 1,   Inf, 1,
    Inf, Inf, 1,   Inf),
  nrow = 4, byrow = TRUE
)

one.simu(func = "prim_mst", meilleur_acm)
one.simu(func = "kruskal_mst", meilleur_acm)
one.simu(func = "prim_mst_rcpp",meilleur_acm)
one.simu(func = "kruskal_mst_rcpp",meilleur_acm)
```

pire cas : entièrement connexe

```{r}
pire_cas_prim <- matrix(
  c(Inf, 2, 3, 4,
    2, Inf, 5, 6,
    3, 5, Inf, 7,
    4, 6, 7, Inf),
  nrow = 4, byrow = TRUE
)

one.simu(func = "prim_mst", pire_cas_prim)
one.simu(func = "kruskal_mst", pire_cas_prim)
one.simu(func = "prim_mst_rcpp",pire_cas_prim)
one.simu(func = "kruskal_mst_rcpp",pire_cas_prim)
```

#### Analyse diverses densités de graphe à taille fixée 

```{r}
library(tidyr) 
library(ggplot2)
library(mstPackage)
densities <- seq(0.1, 1, by=0.1)
n <- 100 # Taille du graphe fixe


density_results <- matrix(NA, length(densities), 4)
colnames(density_results) <- c("prim_mst", "kruskal_mst", "prim_mst_rcpp", "kruskal_mst_rcpp")

for (i in 1:length(densities)) {
  print(round((1 - densities[i]) * n * (n - 1) / 2))
  adj_matrix <- generate_random_adjacency_matrix(n, num_zeros = round((1 - densities[i]) * n * (n - 1) / 2))
  
  # Exécution des simulations pour chaque densité
  for (func in colnames(density_results)) {
    density_results[i, func] <- one.simu(func, adj_matrix)
  }
}


density_df <- as.data.frame(density_results)
density_df$density <- seq(0.1, 1, by = 0.1)

density_long <- pivot_longer(density_df, cols = c("prim_mst", "kruskal_mst", "prim_mst_rcpp", "kruskal_mst_rcpp"), 
                             names_to = "Algorithm", values_to = "Time")

density_long$LogTime <- log(density_long$Time)

ggplot(density_long, aes(x = density, y = LogTime, color = Algorithm)) +
  geom_line() + geom_point() +
  scale_y_continuous(name = "Log(Time)") +
  scale_x_continuous(name = "Density") +
  ggtitle("Impact de la Densité sur le Temps d'Exécution (Log Scale)") +
  theme_minimal()
```

#### Analyse diverses tailles de graphe à densité fixée


```{r}
library(tidyr) 
library(ggplot2)
library(mstPackage) # Assurez-vous que cette bibliothèque contient les implémentations Rcpp

sizes <- seq(5, 100, by = 10) # Différentes tailles à tester
density <- 0.5 # Densité constante

# Stockage des résultats
size_results <- matrix(NA, length(sizes), 4)
colnames(size_results) <- c("prim_mst", "kruskal_mst", "prim_mst_rcpp", "kruskal_mst_rcpp")

for (i in 1:length(sizes)) {
  print(sizes[i])
  adj_matrix <- generate_random_adjacency_matrix(sizes[i], num_zeros = round((1 - density) * sizes[i] * (sizes[i] - 1) / 2))
  
  # Exécution des simulations pour chaque taille de graphe
  for (func in colnames(size_results)) {
    size_results[i, func] <- one.simu(func, adj_matrix)
  }
}

# Convertir les résultats en data frame pour une visualisation avec ggplot2
size_df <- as.data.frame(size_results)
size_df$size <- sizes

# Transformer de wide à long format
size_long <- pivot_longer(size_df, cols = c("prim_mst", "kruskal_mst", "prim_mst_rcpp", "kruskal_mst_rcpp"),
                          names_to = "Algorithm", values_to = "Time")

# Ajouter une colonne pour l'échelle logarithmique
size_long$LogTime <- log(size_long$Time)

# Création du graphique
ggplot(size_long, aes(x = size, y = LogTime, color = Algorithm)) +
  geom_line() + geom_point() +
  scale_y_continuous(name = "Log(Time)") +
  scale_x_continuous(name = "Size of Graph") +
  ggtitle("Impact de la Taille du Graphe sur le Temps d'Exécution (Log Scale)") +
  theme_minimal()
```

#### Analyse diverses poids de graphe à densité et taille fixées


```{r}
library(tidyr) 
library(ggplot2)
library(mstPackage)

n <- 100 # Taille du graphe fixe
density <- 0.5 # Densité constante

# plages de poids à tester
weight_ranges <- list(c(1,10), c(1,20), c(1,50), c(1,100), c(1,200), c(1,500), c(1,1000))

weight_data <- data.frame(Size = integer(),
                          Algorithm = character(),
                          Time = numeric(),
                          LogTime = numeric(),
                          WeightRange = character())

for (range in weight_ranges) {
  print(paste("Testing weight range:", range[1], "-", range[2]))
  adj_matrix <- generate_random_adjacency_matrix(n, num_zeros = round((1 - density) * n * (n - 1) / 2))
  adj_matrix[adj_matrix != Inf] <- sample(range[1]:range[2], sum(adj_matrix != Inf), replace = TRUE)
  
  for (algo in c("prim_mst", "kruskal_mst", "prim_mst_rcpp", "kruskal_mst_rcpp")) {
    time_taken <- one.simu(algo, adj_matrix)
    weight_data <- rbind(weight_data, data.frame(Size = n,
                                                 Algorithm = algo,
                                                 Time = time_taken,
                                                 LogTime = log(time_taken),
                                                 WeightRange = paste(range, collapse = "-")))
  }
}

ggplot(weight_data, aes(x = WeightRange, y = LogTime, group = Algorithm, color = Algorithm)) +
  geom_line() +
  geom_point() +
  theme_minimal() +
  scale_y_continuous(name = "Log(Time)") +
  scale_x_discrete(name = "Weight Range") +
  ggtitle("Impact des Plages de Poids sur le Temps d'Exécution (Log Scale)")
```


#### Analyse de différents cas particuliers 


Graphe disjoint

```{r}
# Un graphe avec deux composantes connexes disjointes
disjoint_graph <- matrix(Inf, nrow=6, ncol=6)
disjoint_graph[1:3, 1:3] <- 1 # Première composante connexe
#disjoint_graph[4:6, 4:6] <- 1 # Deuxième composante connexe
diag(disjoint_graph) <- Inf # Pas de boucles

prim_mst(disjoint_graph)
kruskal_mst(disjoint_graph)
prim_mst_rcpp(disjoint_graph)
kruskal_mst_rcpp(disjoint_graph)
```

Erreur -> remplacer par warning 


Graphe poids uniforme 

```{r}
# Un graphe complet avec des poids uniformes
uniform_weight_graph <- matrix(1, nrow=5, ncol=5)
diag(uniform_weight_graph) <- Inf # Pas de boucles

prim_mst(uniform_weight_graph)
kruskal_mst(uniform_weight_graph)
prim_mst_rcpp(uniform_weight_graph)
kruskal_mst_rcpp(uniform_weight_graph)

one.simu(func = "prim_mst", uniform_weight_graph)
one.simu(func = "kruskal_mst", uniform_weight_graph)
one.simu(func = "prim_mst_rcpp",uniform_weight_graph)
one.simu(func = "kruskal_mst_rcpp",uniform_weight_graph)
```



Graphe cycle complet 

```{r}
# Un cycle complet (chaque sommet connecté à tous les autres)
complete_cycle_graph <- matrix(2, nrow=5, ncol=5)
diag(complete_cycle_graph) <- Inf # Pas de boucles

prim_mst(complete_cycle_graph)
kruskal_mst(complete_cycle_graph)
prim_mst_rcpp(complete_cycle_graph)
kruskal_mst_rcpp(complete_cycle_graph)

one.simu(func = "prim_mst", complete_cycle_graph)
one.simu(func = "kruskal_mst", complete_cycle_graph)
one.simu(func = "prim_mst_rcpp",complete_cycle_graph)
one.simu(func = "kruskal_mst_rcpp",complete_cycle_graph)
```

Graphe étoile 

```{r}
# Un graphe en étoile avec un nœud central
star_graph <- matrix(Inf, nrow=5, ncol=5)
star_graph[1, 2:5] <- 1
star_graph[2:5, 1] <- 1
diag(star_graph) <- Inf # Pas de boucles


prim_mst(star_graph)
kruskal_mst(star_graph)
prim_mst_rcpp(star_graph)
kruskal_mst_rcpp(star_graph)

one.simu(func = "prim_mst", star_graph)
one.simu(func = "kruskal_mst", star_graph)
one.simu(func = "prim_mst_rcpp",star_graph)
one.simu(func = "kruskal_mst_rcpp",star_graph)
```


Graphe linéaire / chainé

```{r}
# Un graphe linéaire ou chaîne
linear_graph <- matrix(Inf, nrow=5, ncol=5)
linear_graph[row(linear_graph) == col(linear_graph) + 1] <- 1
linear_graph[row(linear_graph) + 1 == col(linear_graph)] <- 1

prim_mst(linear_graph)
kruskal_mst(linear_graph)
prim_mst_rcpp(linear_graph)
kruskal_mst_rcpp(linear_graph)

one.simu(func = "prim_mst", linear_graph)
one.simu(func = "kruskal_mst", linear_graph)
one.simu(func = "prim_mst_rcpp",linear_graph)
one.simu(func = "kruskal_mst_rcpp",linear_graph)
```



Graphe poids extremes 

```{r}
# Un graphe avec des poids extrêmes
extreme_weight_graph <- matrix(runif(25, 1, 100), nrow=5)
extreme_weight_graph <- (extreme_weight_graph + t(extreme_weight_graph)) / 2
diag(extreme_weight_graph) <- Inf # Pas de boucles


prim_mst(extreme_weight_graph)
kruskal_mst(extreme_weight_graph)
prim_mst_rcpp(extreme_weight_graph)
kruskal_mst_rcpp(extreme_weight_graph)

one.simu(func = "prim_mst", extreme_weight_graph)
one.simu(func = "kruskal_mst", extreme_weight_graph)
one.simu(func = "prim_mst_rcpp",extreme_weight_graph)
one.simu(func = "kruskal_mst_rcpp",extreme_weight_graph)
```




Graphe complet pondérés de facon non uniforme 

```{r}
# Un graphe complet avec des poids non uniformes
non_uniform_complete_graph <- matrix(sample(1:10, 25, replace = TRUE), nrow=5)
non_uniform_complete_graph <- (non_uniform_complete_graph + t(non_uniform_complete_graph)) / 2
diag(non_uniform_complete_graph) <- Inf # Pas de boucles

prim_mst(non_uniform_complete_graph)
kruskal_mst(non_uniform_complete_graph)
prim_mst_rcpp(non_uniform_complete_graph)
kruskal_mst_rcpp(non_uniform_complete_graph)

one.simu(func = "prim_mst", non_uniform_complete_graph)
one.simu(func = "kruskal_mst", non_uniform_complete_graph)
one.simu(func = "prim_mst_rcpp",non_uniform_complete_graph)
one.simu(func = "kruskal_mst_rcpp",non_uniform_complete_graph)
```


Graphes à Multiples Égalités de Poids Minimal 

```{r}

# Un graphe avec de multiples arêtes ayant le même poids minimal
multiple_min_weights_graph <- matrix(sample(c(rep(1, 5), 2:10), 25, replace = TRUE), nrow=5)
multiple_min_weights_graph <- (multiple_min_weights_graph + t(multiple_min_weights_graph)) / 2
diag(multiple_min_weights_graph) <- Inf # Pas de boucles


prim_mst(multiple_min_weights_graph)
kruskal_mst(multiple_min_weights_graph)
prim_mst_rcpp(multiple_min_weights_graph)
kruskal_mst_rcpp(multiple_min_weights_graph)

one.simu(func = "prim_mst", multiple_min_weights_graph)
one.simu(func = "kruskal_mst", multiple_min_weights_graph)
one.simu(func = "prim_mst_rcpp",multiple_min_weights_graph)
one.simu(func = "kruskal_mst_rcpp",multiple_min_weights_graph)
```




Graphes avec Boucles

```{r}
# Un graphe avec des boucles (généralement non souhaitables dans un graphe simple)
graph_with_loops <- matrix(sample(1:10, 25, replace = TRUE), nrow=5)
graph_with_loops <- (graph_with_loops + t(graph_with_loops)) / 2

prim_mst(graph_with_loops)
kruskal_mst(graph_with_loops)
prim_mst_rcpp(graph_with_loops)
kruskal_mst_rcpp(graph_with_loops)

one.simu(func = "prim_mst", graph_with_loops)
one.simu(func = "kruskal_mst", graph_with_loops)
one.simu(func = "prim_mst_rcpp",graph_with_loops)
one.simu(func = "kruskal_mst_rcpp",graph_with_loops)

```

Graphes avec Poids Négatifs 

```{r}
# Un graphe avec des poids négatifs (pas standard pour MST)
negative_weights_graph <- matrix(sample(-10:10, 25, replace = TRUE), nrow=5)
negative_weights_graph <- (negative_weights_graph + t(negative_weights_graph)) / 2
diag(negative_weights_graph) <- Inf # Pas de boucles

prim_mst(negative_weights_graph)
kruskal_mst(negative_weights_graph)
prim_mst_rcpp(negative_weights_graph)
kruskal_mst_rcpp(negative_weights_graph)

one.simu(func = "prim_mst", negative_weights_graph)
one.simu(func = "kruskal_mst", negative_weights_graph)
one.simu(func = "prim_mst_rcpp",negative_weights_graph)
one.simu(func = "kruskal_mst_rcpp",negative_weights_graph)
```














à ranger en dessous











Dans cette partie, nous allons pouvoir comparer les temps d'exécution des deux algorithmes, mais aussi des deux langages utilisées : R et C++.

### Comparaison des fonctions

On peut commencer par définir une fonction qui nous permettra de calculer les temps d'exécution de chaque algorithme implémenté, pour les deux langages :

On peut alors calculer pour un n fixé, le temps d'exécution de chaque algorithme, pour une même matrice d'adjacence :

```{r}
n <- 10
adj_matrix <- generate_random_adjacency_matrix(n)
one.simu(func = "prim_mst", adj_matrix)
one.simu(func = "kruskal_mst", adj_matrix)
one.simu(func = "prim_mst_rcpp",adj_matrix)
one.simu(func = "kruskal_mst_rcpp",adj_matrix)
```

Ainsi, .......

\
On peut aussi calculer les temps d'éxecution pour un n fixé, en répétant plusieur fois le nombre de réalisation des algorithmes.

```{r}
nbSimus <- 10
adj_matrix <- generate_random_adjacency_matrix(100)
time1 <- 0
time2 <- 0
time3 <- 0
time4 <- 0
for(i in 1:nbSimus){time1 <- time1 + one.simu(func = "prim_mst", adj_matrix)}
for(i in 1:nbSimus){time2 <- time2 + one.simu(func = "kruskal_mst", adj_matrix)}
for(i in 1:nbSimus){time3 <- time3 + one.simu(func = "prim_mst_rcpp", adj_matrix)}
for(i in 1:nbSimus){time4 <- time4 + one.simu(func = "kruskal_mst_rcpp", adj_matrix)}
```

On peut alors étudier les vitesses selon le langage ou l'algorithme utilisés :

```{r}
#gain R -> rcpp
time1/time3
time2/time4

#gain prim -> kruskal
time1/time2
time3/time4

#max gain
time1/time4 #à adapter

```

\
Ainsi ....

On peut ensuite implémenter fonction pour

### Comparaison des algorithmes Prim et Kruskal

### Comparaison des langages

#### En Rcpp

Benchmark

```{r}
library(microbenchmark)
library(ggplot2)
n <- 100
adj_matrix <- generate_random_adjacency_matrix(n)
res <- microbenchmark(one.simu(func = "prim_mst_rcpp", ajd_matrix), one.simu(func = "kruskal_mst_rcpp", adj_matrix), times = 50)
autoplot(res)
res
```

```{r}
res2 <- microbenchmark(one.simu(func = "prim_mst", ajd_matrix), one.simu(func = "kruskal_mst", adj_matrix), times = 50)
autoplot(res2)
res2
```

```{r}
res3 <- microbenchmark(one.simu(func = "prim_mst_rcpp", ajd_matrix), one.simu(func = "kruskal_mst_rcpp", adj_matrix), one.simu(func = "prim_mst", ajd_matrix), one.simu(func = "kruskal_mst", ajd_matrix), times = 50)
autoplot(res3)
res3
```

Graphique log(n) vs log(T(n))

```{r}

```

```{r}
n = 5
a = generate_random_adjacency_matrix(n)
a
kruskal_mst(a)
prim_mst(a)
```

## Références
